<!doctype html>
<html>
  <head>
    <title>Video Feed Monitoring</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <!-- Inline favicon to avoid browser 404 for /favicon.ico -->
    <link
      rel="icon"
      href="data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16'%3E%3Crect width='100%25' height='100%25' fill='%23007ACC'/%3E%3C/svg%3E"
    />
  </head>
  <body>
    <h1>Live Video Feed</h1>
    <div
      style="
        width: 640px;
        height: 480px;
        background: #000;
        border: 2px solid #333;
        display: flex;
        align-items: center;
        justify-content: center;
      "
    >
      <canvas
        id="video-canvas"
        width="640"
        height="480"
        style="display: none; width: 100%; height: 100%; object-fit: contain"
      ></canvas>
    </div>
    <p>Server: <span id="server-status">Connecting...</span></p>
    <p>Stream: <span id="stream-status">Offline</span></p>

    <script>
      const socket = io();
      const canvas = document.getElementById('video-canvas');
      const ctx = canvas.getContext('2d');
      const serverStatus = document.getElementById('server-status');
      const streamStatus = document.getElementById('stream-status');
      let classOverlay = null; // { lines: string[], expiry: timestamp }

      socket.on('connect', () => {
        serverStatus.innerText = 'Connected';
        serverStatus.style.color = 'green';
      });

      socket.on('classification', (data) => {
        // data: { image, predictions: [{label, probability}], ts }
        try {
          const preds = Array.isArray(data.predictions) ? data.predictions : [];
          const lines = preds.map(
            (p) => `${p.label}: ${(p.probability * 100).toFixed(1)}%`,
          );
          if (
            lines.length === 0 &&
            data.predictions &&
            typeof data.predictions === 'object'
          ) {
            // single prediction object case
            const p = data.predictions;
            lines.push(
              `${p.label || p.id || ''}: ${((p.probability || p.prob) * 100 || 0).toFixed(1)}%`,
            );
          }
          classOverlay = { lines: lines, expiry: Date.now() + 5000 };
        } catch (err) {
          console.warn('Invalid classification payload', err, data);
        }
      });

      // Also handle direct producer payloads (video-frame) which include a
      // base64 `frame` and optional `classification_percentages` or `classifications`.
      socket.on('video-frame', (data) => {
        try {
          if (!data || typeof data !== 'object' || !('frame' in data)) return;
          const b64 = data.frame;
          const img = new Image();
          img.onload = () => {
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            // draw base image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);

            // draw predictions if present (expect xyxy coordinates)
            if (Array.isArray(data.predictions)) {
              ctx.lineWidth = 2;
              ctx.font = '16px sans-serif';
              data.predictions.forEach((p) => {
                try {
                  const xy = p.xyxy || p.box || null;
                  if (!xy || xy.length < 4) return;
                  const x1 = xy[0];
                  const y1 = xy[1];
                  const x2 = xy[2];
                  const y2 = xy[3];
                  const w = x2 - x1;
                  const h = y2 - y1;

                  const cls = p.class != null ? String(p.class) : '0';
                  const colorMap = [
                    '#00FF00',
                    '#FF0000',
                    '#00FFFF',
                    '#FFFF00',
                    '#FF00FF',
                  ];
                  const color =
                    colorMap[parseInt(cls) % colorMap.length] || '#00FF00';
                  ctx.strokeStyle = color;
                  ctx.fillStyle = color;
                  ctx.strokeRect(x1, y1, w, h);

                  const conf =
                    p.confidence != null
                      ? (p.confidence * 100).toFixed(1) + '%'
                      : p.confidence != null
                        ? p.confidence
                        : '';
                  const label =
                    (p.class != null ? 'Class ' + p.class : '') +
                    (conf ? ' ' + conf : '');
                  const textX = x1 + 4;
                  const textY = y1 + 16;
                  const metrics = ctx.measureText(label);
                  const textW = metrics.width + 6;
                  const textH = 18;
                  ctx.globalAlpha = 0.6;
                  ctx.fillRect(textX - 3, textY - 14, textW, textH);
                  ctx.globalAlpha = 1.0;
                  ctx.fillStyle = '#000';
                  ctx.fillText(label, textX, textY);
                  ctx.fillStyle = color;
                } catch (err) {
                  // ignore per-prediction errors
                }
              });
            }

            // build overlay lines from percentages or classifications
            let lines = [];
            if (
              data.classification_percentages &&
              typeof data.classification_percentages === 'object'
            ) {
              Object.keys(data.classification_percentages).forEach((k) => {
                lines.push(`${k}: ${data.classification_percentages[k]}%`);
              });
            } else if (
              Array.isArray(data.classifications) &&
              data.classifications.length
            ) {
              lines = data.classifications.map(
                (c) => `${c.label}: ${(c.score * 100).toFixed(2)}%`,
              );
            }
            if (lines.length) {
              classOverlay = { lines: lines, expiry: Date.now() + 5000 };
            }

            // draw classification overlay immediately (same style as stream handler)
            try {
              if (classOverlay && Date.now() < classOverlay.expiry) {
                ctx.save();
                ctx.font = '18px sans-serif';
                const padding = 8;
                let maxW = 0;
                classOverlay.lines.forEach((ln) => {
                  const m = ctx.measureText(ln);
                  if (m.width > maxW) maxW = m.width;
                });
                const boxW = maxW + padding * 2;
                const boxH = classOverlay.lines.length * 20 + padding * 2;
                const x = 8;
                const y = 8;
                ctx.globalAlpha = 0.7;
                ctx.fillStyle = '#000';
                ctx.fillRect(x, y, boxW, boxH);
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = '#fff';
                classOverlay.lines.forEach((ln, idx) => {
                  ctx.fillText(ln, x + padding, y + padding + 18 * (idx + 0));
                });
                ctx.restore();
              }
            } catch (err) {
              console.warn('Overlay draw error', err);
            }

            canvas.style.display = 'block';
          };
          img.onerror = (e) => console.error('Image load error', e);
          img.src = 'data:image/jpeg;base64,' + b64;
        } catch (err) {
          console.warn('video-frame handling error', err, data);
        }
      });

      socket.on('stream', (data) => {
        // Expect JSON object { id, frame, predictions?, stats? }
        // frame is a base64 JPEG string (no data: prefix)
        try {
          if (!data || typeof data !== 'object' || !('frame' in data)) {
            // Fallback: assume binary ArrayBuffer
            const blob = new Blob([data], { type: 'image/jpeg' });
            const url = URL.createObjectURL(blob);
            const img = new Image();
            img.onload = () => {
              canvas.width = img.naturalWidth;
              canvas.height = img.naturalHeight;
              ctx.drawImage(img, 0, 0);
              // draw possible classification overlay
              try {
                if (classOverlay && Date.now() < classOverlay.expiry) {
                  ctx.save();
                  ctx.font = '18px sans-serif';
                  const lines = classOverlay.lines || [];
                  const padding = 8;
                  let maxW = 0;
                  lines.forEach((ln) => {
                    const m = ctx.measureText(ln);
                    if (m.width > maxW) maxW = m.width;
                  });
                  const boxW = maxW + padding * 2;
                  const boxH = lines.length * 20 + padding * 2;
                  const x = 8;
                  const y = 8;
                  ctx.globalAlpha = 0.7;
                  ctx.fillStyle = '#000';
                  ctx.fillRect(x, y, boxW, boxH);
                  ctx.globalAlpha = 1.0;
                  ctx.fillStyle = '#fff';
                  lines.forEach((ln, idx) => {
                    ctx.fillText(ln, x + padding, y + padding + 18 * (idx + 0));
                  });
                  ctx.restore();
                }
              } catch (err) {
                console.warn('Overlay draw error', err);
              }
              canvas.style.display = 'block';
              URL.revokeObjectURL(url);
            };
            img.src = url;
            return;
          }

          const b64 = data.frame;
          const img = new Image();
          img.onload = () => {
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            // draw base image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);

            // draw predictions if present (expect xyxy coordinates)
            if (Array.isArray(data.predictions)) {
              ctx.lineWidth = 2;
              ctx.font = '16px sans-serif';
              data.predictions.forEach((p) => {
                try {
                  const xy = p.xyxy || p.box || null;
                  if (!xy || xy.length < 4) return;
                  const x1 = xy[0];
                  const y1 = xy[1];
                  const x2 = xy[2];
                  const y2 = xy[3];
                  const w = x2 - x1;
                  const h = y2 - y1;

                  // color by class if available
                  const cls = p.class != null ? String(p.class) : '0';
                  const colorMap = [
                    '#00FF00',
                    '#FF0000',
                    '#00FFFF',
                    '#FFFF00',
                    '#FF00FF',
                  ];
                  const color =
                    colorMap[parseInt(cls) % colorMap.length] || '#00FF00';
                  ctx.strokeStyle = color;
                  ctx.fillStyle = color;
                  ctx.strokeRect(x1, y1, w, h);

                  // label text
                  const conf =
                    p.confidence != null
                      ? (p.confidence * 100).toFixed(1) + '%'
                      : p.confidence != null
                        ? p.confidence
                        : '';
                  const label =
                    (p.class != null ? 'Class ' + p.class : '') +
                    (conf ? ' ' + conf : '');
                  const textX = x1 + 4;
                  const textY = y1 + 16;
                  // background for text
                  const metrics = ctx.measureText(label);
                  const textW = metrics.width + 6;
                  const textH = 18;
                  ctx.globalAlpha = 0.6;
                  ctx.fillRect(textX - 3, textY - 14, textW, textH);
                  ctx.globalAlpha = 1.0;
                  ctx.fillStyle = '#000';
                  ctx.fillText(label, textX, textY);
                  ctx.fillStyle = color;
                } catch (err) {
                  // ignore per-prediction errors
                }
              });
            }

            // draw classification overlay if present
            try {
              if (classOverlay && Date.now() < classOverlay.expiry) {
                const lines = classOverlay.lines || [];
                if (lines.length) {
                  ctx.save();
                  ctx.font = '18px sans-serif';
                  const padding = 8;
                  let maxW = 0;
                  lines.forEach((ln) => {
                    const m = ctx.measureText(ln);
                    if (m.width > maxW) maxW = m.width;
                  });
                  const boxW = maxW + padding * 2;
                  const boxH = lines.length * 20 + padding * 2;
                  const x = 8;
                  const y = 8;
                  ctx.globalAlpha = 0.7;
                  ctx.fillStyle = '#000';
                  ctx.fillRect(x, y, boxW, boxH);
                  ctx.globalAlpha = 1.0;
                  ctx.fillStyle = '#fff';
                  lines.forEach((ln, idx) => {
                    ctx.fillText(ln, x + padding, y + padding + 18 * (idx + 0));
                  });
                  ctx.restore();
                }
              }
            } catch (err) {
              console.warn('Overlay draw error', err);
            }

            canvas.style.display = 'block';
          };
          img.onerror = (e) => console.error('Image load error', e);
          img.src = 'data:image/jpeg;base64,' + b64;
        } catch (err) {
          console.error('Failed to render stream frame', err, data);
        }
      });

      socket.on('stream-status', (data) => {
        if (data.active) {
          streamStatus.innerText = 'Online';
          streamStatus.style.color = 'green';
        } else {
          streamStatus.innerText = 'Offline';
          streamStatus.style.color = 'red';
          canvas.style.display = 'none';
          // clear canvas
          try {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
          } catch (e) {}
        }
      });

      socket.on('disconnect', () => {
        serverStatus.innerText = 'Disconnected';
        serverStatus.style.color = 'red';
        streamStatus.innerText = 'Offline';
        streamStatus.style.color = 'red';
        canvas.style.display = 'none';
        try {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        } catch (e) {}
      });
    </script>
  </body>
</html>
